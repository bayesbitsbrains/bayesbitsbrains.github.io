  // Call Hugging Face GPT-2 compression API using queue system
  const callGPT2Compression = async (text: string): Promise<{ algorithm: string; bits: number; ratio: string; compression_progression?: any[] } | null> => {
    try {
      console.log('Calling GPT-2 API with text:', text.substring(0, 50) + '...');
      
      const sessionHash = Math.random().toString(36).substring(2);
      
      const queueResponse = await fetch(
        'https://vaclavrozhon-gpt2-compression-api.hf.space/gradio_api/queue/join',
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            data: [text],
            event_data: null,
            fn_index: 0,        // Use fn_index 0 since we have one function
            session_hash: sessionHash
          })
        }
      );
      
      if (!queueResponse.ok) {
        throw new Error(`Queue join failed: ${queueResponse.status}`);
      }
      
      // Use EventSource to get results
      return new Promise((resolve, reject) => {
        const eventSource = new EventSource(
          `https://vaclavrozhon-gpt2-compression-api.hf.space/gradio_api/queue/data?session_hash=${sessionHash}`
        );
        
        const timeout = setTimeout(() => {
          eventSource.close();
          reject(new Error('GPT-2 processing timeout'));
        }, 120000);  // Increase timeout to 2 minutes for long texts
          
        eventSource.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);
            
            if (data.msg === 'process_completed') {
              clearTimeout(timeout);
              eventSource.close();
              
              if (data.output && data.output.data) {
                const jsonString = data.output.data[0];
                console.log('Raw JSON string from API:', jsonString);
                
                try {
                  const compressionData = JSON.parse(jsonString);
                  
                  if (compressionData.error) {
                    console.error('GPT-2 compression failed:', compressionData.error);
                    resolve(null);
                  } else if (compressionData.algorithm && compressionData.bits && compressionData.ratio) {
                    resolve({
                      algorithm: compressionData.algorithm,
                      bits: compressionData.bits,
                      ratio: compressionData.ratio,
                      compression_progression: compressionData.compression_progression || []
                    });
                  } else {
                    console.error('Invalid data format:', compressionData);
                    resolve(null);
                  }
                } catch (parseError) {
                  console.error('Failed to parse JSON:', parseError, 'Raw:', jsonString);
                  resolve(null);
                }
              } else {
                console.error('No output data');
                resolve(null);
              }
            }
          } catch (e) {
            // Continue listening
          }
        };
        
        eventSource.onerror = () => {
          clearTimeout(timeout);
          eventSource.close();
          resolve(null);
        };
      });
      
    } catch (error) {
      console.error('Failed to call GPT-2 API:', error);
      return null;
    }
  };